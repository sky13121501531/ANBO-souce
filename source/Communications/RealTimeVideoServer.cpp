///////////////////////////////////////////////////////////////////////////////////////////
// 文件名：RealTimeVideoServer.cpp
// 创建者：jiangcheng
// 创建时间：2009-05-20
// 内容描述：实时视频服务器端处理类
///////////////////////////////////////////////////////////////////////////////////////////
#pragma warning(disable:4996)
#include "RealTimeVideoServer.h"
#include "CommunicationMgr.h"
#include "TsSenderMgr.h"
#include <string>
#include <sstream>
#include <iostream>
#include "../Foundation/OSFunction.h"
#include "../Foundation/StrUtil.h"
#include "../Foundation/TypeDef.h"
#include "../Foundation/PropManager.h"

using namespace std;

const int MAXDEVICEIDNUM = 2;

RealTimeVideoServer::RealTimeVideoServer()
{
	bFlag = false;
}

RealTimeVideoServer::~RealTimeVideoServer()
{

}

int RealTimeVideoServer::Open(ACE_Addr &addr)
{
	if (peer_acceptor.open(addr) == -1)//监听实时视频服务器端口
	{
		return -1;
	}
	else
	{
		ACE_DEBUG((LM_DEBUG,"(%T | %t)视频服务成功启动................\n"));
	}
	return 0;
}

int RealTimeVideoServer::handle_input(ACE_HANDLE handle)
{
	ACE_SOCK_Stream client;//连接socket
	ACE_INET_Addr clientAddr;//客户端地址信息

	if (this->peer_acceptor.accept(client,&clientAddr) == -1)//接受客户端连接
	{
		ACE_DEBUG((LM_ERROR,"(%T | %t)接收用户连接错误\n"));
		client.close();
		return 0;
	}
	
	const int PKGSIZE = 188;
	int value =PKGSIZE*5000;	

	//设置socket发送接收缓冲
	client.set_option(SOL_SOCKET,SO_SNDBUF,(char*)&value,sizeof(value));
	client.set_option(SOL_SOCKET,SO_RCVBUF,(char*)&value,sizeof(value));

	list<int> userdeviceilist;
	if (false == RecvDeviceID(client,userdeviceilist)) //接收用户数据,得到通道号
	{
		ACE_DEBUG((LM_DEBUG,"(%T | %t)用户(%s:%d):接收数据失败\n",clientAddr.get_host_addr(),clientAddr.get_port_number()));
		client.close();
		return 0;
	}
	
	if (userdeviceilist.empty())
	{
		ACE_DEBUG((LM_DEBUG,"(%T | %t)用户(%s:%d):无通道错误\n",clientAddr.get_host_addr(),clientAddr.get_port_number()));
		client.close();
		return 0;
	}
	//分析用户通道数据
	list<int>::iterator ptr_user = userdeviceilist.begin();
	for (;ptr_user!=userdeviceilist.end();++ptr_user)
	{
		if (false == PROPMANAGER::instance()->IsDeviceAvaiable(*ptr_user) &&
			false == PROPMANAGER::instance()->IsRoundChannel(*ptr_user))
		{
			ACE_DEBUG((LM_DEBUG,"(%T | %t)用户(%s:%d):通道[%d]错误\n",clientAddr.get_host_addr(),clientAddr.get_port_number(),(*ptr_user)));
			client.close();
			return 0;
		}
	}
	
	if (false == SendHttpHeader(client))//发送回复数据
	{
		ACE_DEBUG((LM_DEBUG,"(%T | %t)用户(%s:%d):发送回复数据失败\n",clientAddr.get_host_addr(),clientAddr.get_port_number()));
		client.close();
		return 0;
	}
	//保存连接的客户端信息
	ptr_user = userdeviceilist.begin();
	for (;ptr_user!=userdeviceilist.end();++ptr_user)
	{
		sVedioUserInfo tempuserinfo;
		tempuserinfo.client		= client;
		tempuserinfo.DeviceID	= StrUtil::Int2Str(*ptr_user);
		tempuserinfo.IP			= clientAddr.get_host_addr();
		tempuserinfo.Port		= StrUtil::Int2Str(clientAddr.get_port_number());

		//将客户添加到相应的数据发送队列
		TSSENDERMGR::instance()->AddClient(*ptr_user,tempuserinfo);
		ACE_DEBUG((LM_DEBUG,"(%T | %t)用户连接(%s:%d):通道[%d]\n",clientAddr.get_host_addr(),clientAddr.get_port_number(),*ptr_user));
	}

	return 0;
}

int RealTimeVideoServer::handle_close(ACE_HANDLE handle, ACE_Reactor_Mask close_mask)
{
	//移除视频服务器
	close_mask = ACE_Event_Handler::ALL_EVENTS_MASK | ACE_Event_Handler::DONT_CALL;
	COMMUNICATIONMGR::instance()->AccessMyReactor()->GetReactor()->remove_handler(this,close_mask);
	this->peer_acceptor.close();

	delete this;
	return 0;
}

ACE_HANDLE RealTimeVideoServer::get_handle(void) const
{
	return this->peer_acceptor.get_handle();
}

int RealTimeVideoServer::Stop()
{
	ACE_Reactor_Mask close_mask = ACE_Event_Handler::ALL_EVENTS_MASK | ACE_Event_Handler::DONT_CALL;
	COMMUNICATIONMGR::instance()->AccessMyReactor()->GetReactor()->remove_handler(this,close_mask);
	this->peer_acceptor.close();

	return 0;
}
bool RealTimeVideoServer:: RecvDeviceID(ACE_SOCK_Stream& newclient,list<int>& deviceIDlist)
{
	int countTimes = 10;//接收客户端发送数据的次数
	char RecvBuf[4096] = {0};
	int RecvCount = -1;
	try
	{
		ACE_Time_Value TimeOut(0,100);
		while(--countTimes)
		{
			ssize_t RecvCount = newclient.recv(RecvBuf,4096,&TimeOut);//接收数据
		
			if(RecvCount < 4 || RecvCount == SOCKET_ERROR)//socket错误
			{
				OSFunction::Sleep(0,10);
				continue;
			}
			
			char szSeps[] = "\n";

			//wz_110125:解决cpToken为NULL时，string dsp(cpToken)出现的异常
			char *cpToken = strtok(RecvBuf, szSeps);
			if (cpToken == NULL)
			{
				return false;
			}
			string dsp(cpToken);

			dsp = dsp.substr(dsp.find_first_of("/"));
			dsp = dsp.substr(0,dsp.find_first_of(" "));
			std::stringstream stream(dsp);
			string strTemp;
			//客户通过端连接获得用户所连接的通道号，http://192.168.100.56:8080/1/2
			while (getline(stream,strTemp,'/'))
			{
				if (strTemp != "")
				{
					int deviceid = StrUtil::Str2Int(strTemp);//得到连接的通道号
					deviceIDlist.push_back(deviceid);
				}
			}
			break;
		}
	}
	catch(...)
	{
		;
	}
	return true;
}
bool RealTimeVideoServer::SendHttpHeader(ACE_SOCK_Stream& newclient)
{
	std::string HttpHeader = "HTTP/1.1 200 OK\r\n";//http响应头
	HttpHeader += std::string("Content-Type: video/mpeg\r\n") + std::string("Cache-Control: no-cache\r\nContent-Length: 0-\r\n") + std::string("\r\n");

	ACE_Message_Block *MBHttpHeader = new ACE_Message_Block(HttpHeader.length());
	memcpy(MBHttpHeader->wr_ptr(),HttpHeader.c_str(),HttpHeader.length());
	MBHttpHeader->wr_ptr(HttpHeader.length());

	ACE_Time_Value TimeOut(0,100);
	int nCount = newclient.send_n(MBHttpHeader,&TimeOut);//发送http响应头数据
	if(nCount<=0)
		return false;	
	return true;
}